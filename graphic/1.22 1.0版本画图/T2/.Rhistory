merged_data$case_count[is.na(merged_data$case_count)] <- 1
merged_data$point_size <- 0.8 + (merged_data$case_count / max(merged_data$case_count)) * 2
# Create color vector for points.
merged_data$year_factor <- as.factor(merged_data$year)
point_colors <- ifelse(merged_data$year_factor == "2019", color_year_2019, color_year_2020)
# Define plot boundaries.
x_lim <- range(merged_data$longitude)
y_lim <- range(merged_data$latitude)
z_lim <- c(0, max(merged_data$time_days) + 20)
# Create an extent object for downloading elevation data.
extent_for_download <- extent(x_lim + c(-0.1, 0.1), y_lim + c(-0.1, 0.1))
# Download the elevation data (Digital Elevation Model).
cat("Downloading elevation data... (This may take a moment on first run)\n")
elevation_raster <- get_elev_raster(locations = extent_for_download, z = 9, prj = "EPSG:4326")
cat("Downloading elevation data... (This may take a moment on first run)\n")
elevation_raster <- get_elev_raster(locations = extent_for_download, z = 9, prj = "EPSG:4326")
# 用 extent 做一个 RasterLayer 模板（关键：这才是 get_elev_raster 接受的类型之一）
aoi_raster <- raster(extent_for_download, nrows = 50, ncols = 50)
crs(aoi_raster) <- CRS("EPSG:4326")
cat("Downloading elevation data... (This may take a moment on first run)\n")
elevation_raster <- get_elev_raster(locations = aoi_raster, z = 9, clip = "bbox")
# Create a subtle grayscale color ramp for the terrain map.
terrain_colors <- colorRampPalette(c(color_palette$grey_light, color_palette$grey_purple, "#A0A0B0"))(100)
# --- 2. Data Loading and Preparation ---
# Read the data
spatiotemporal_data <- read.csv(spatial_data_path)
seasonal_data <- read.csv(seasonal_data_path)
# Convert 'detection_date' to Date objects and create time axis.
spatiotemporal_data$detection_date <- as.Date(spatiotemporal_data$detection_date)
min_date <- min(spatiotemporal_data$detection_date)
spatiotemporal_data$time_days <- as.numeric(spatiotemporal_data$detection_date - min_date)
# Merge with seasonal data for point sizing.
spatiotemporal_data$month <- as.numeric(format(spatiotemporal_data$detection_date, "%m"))
merged_data <- merge(spatiotemporal_data, seasonal_data, by = "month", all.x = TRUE)
merged_data$case_count[is.na(merged_data$case_count)] <- 1
merged_data$point_size <- 0.8 + (merged_data$case_count / max(merged_data$case_count)) * 2
# Create color vector for points.
merged_data$year_factor <- as.factor(merged_data$year)
point_colors <- ifelse(merged_data$year_factor == "2019", color_year_2019, color_year_2020)
# --- 3. Get and Process Topographic Data ---
# Define plot boundaries.
x_lim <- range(merged_data$longitude)
y_lim <- range(merged_data$latitude)
z_lim <- c(0, max(merged_data$time_days) + 20)
# Create an extent object for downloading elevation data.
extent_for_download <- extent(x_lim + c(-0.1, 0.1), y_lim + c(-0.1, 0.1))
# 用 extent 做一个 RasterLayer 模板（关键：这才是 get_elev_raster 接受的类型之一）
aoi_raster <- raster(extent_for_download, nrows = 50, ncols = 50)
crs(aoi_raster) <- CRS("EPSG:4326")
cat("Downloading elevation data... (This may take a moment on first run)\n")
elevation_raster <- get_elev_raster(locations = aoi_raster, z = 9, clip = "bbox")
library(plot3D)
library(svglite)
library(raster)
library(elevatr)
# Define file paths.
spatial_data_path  <- "E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/t1_spatiotemporal_data.csv"
seasonal_data_path <- "E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/t1_seasonal_trend_data.csv"
output_path        <- "E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图"
# Define the output filename.
output_filename <- "3D_Plot_with_Topographic_Map_Corrected_Final.svg"
# Define the color palette from your request.
color_palette <- list(
purple_dark = "#B6B3D6",
coral       = "#F1837A",
grey_purple = "#D5D3DE",
grey_light  = "#D5D1D1"
)
# Assign colors for main plot elements.
color_year_2019 <- color_palette$coral
color_year_2020 <- color_palette$purple_dark
# Create a subtle grayscale color ramp for the terrain map.
terrain_colors <- colorRampPalette(
c(color_palette$grey_light, color_palette$grey_purple, "#A0A0B0")
)(100)
# --- 2. Data Loading and Preparation ---
# Read the data
spatiotemporal_data <- read.csv(spatial_data_path)
seasonal_data       <- read.csv(seasonal_data_path)
# Convert 'detection_date' to Date objects and create time axis.
spatiotemporal_data$detection_date <- as.Date(spatiotemporal_data$detection_date)
min_date <- min(spatiotemporal_data$detection_date, na.rm = TRUE)
spatiotemporal_data$time_days <- as.numeric(spatiotemporal_data$detection_date - min_date)
# Merge with seasonal data for point sizing.
spatiotemporal_data$month <- as.numeric(format(spatiotemporal_data$detection_date, "%m"))
merged_data <- merge(spatiotemporal_data, seasonal_data, by = "month", all.x = TRUE)
# Fill missing case counts & scale sizes
merged_data$case_count[is.na(merged_data$case_count)] <- 1
merged_data$point_size <- 0.8 + (merged_data$case_count / max(merged_data$case_count, na.rm = TRUE)) * 2
# Create color vector for points.
merged_data$year_factor <- as.factor(merged_data$year)
point_colors <- ifelse(merged_data$year_factor == "2019", color_year_2019, color_year_2020)
# --- 3. Get and Process Topographic Data (FIXED) ---
# Define plot boundaries.
x_lim <- range(merged_data$longitude, na.rm = TRUE)
y_lim <- range(merged_data$latitude,  na.rm = TRUE)
z_lim <- c(0, max(merged_data$time_days, na.rm = TRUE) + 20)
# Expand bounding box a bit for nicer base map margins.
xmin <- x_lim[1] - 0.1
xmax <- x_lim[2] + 0.1
ymin <- y_lim[1] - 0.1
ymax <- y_lim[2] + 0.1
# IMPORTANT FIX:
# get_elev_raster() in newer elevatr expects locations like data.frame(x,y) or sf,
# not raster::extent / RasterLayer. We pass two corner points to define the bbox.
loc_df <- data.frame(
x = c(xmin, xmax),
y = c(ymin, ymax)
)
cat("Downloading elevation data... (This may take a moment on first run)\n")
elevation_raster <- get_elev_raster(
locations = loc_df,
z         = 9,
prj       = "EPSG:4326",
clip      = "bbox"
)
cat("Download complete.\n")
# If elevatr returns a terra SpatRaster on your system, convert to RasterLayer for raster::* helpers
if (inherits(elevation_raster, "SpatRaster")) {
elevation_raster <- raster::raster(elevation_raster)
}
# Get X and Y coordinates from the raster.
elev_x <- xFromCol(elevation_raster, 1:ncol(elevation_raster)) # Longitude values
elev_y <- yFromRow(elevation_raster, 1:nrow(elevation_raster)) # Latitude values
# Convert the raster to a matrix.
elevation_matrix <- raster::as.matrix(elevation_raster)
# CRITICAL (your plot3D dimension/orientation fix):
# plot3D::image3D expects rows=x and cols=y, but raster::as.matrix is row=y, col=x
t_elevation_matrix <- t(elevation_matrix)
# Set up the SVG output device.
svglite(file.path(output_path, output_filename), width = 10, height = 8)
# Set the viewing angle.
phi <- 25
theta <- -45
# Set up the empty plot box and capture the transformation matrix 'pmat'.
pmat <- scatter3D(
x = merged_data$longitude, y = merged_data$latitude, z = merged_data$time_days,
type = "n", bty = "g", ticktype = "detailed",
xlab = "\n\nLongitude", ylab = "\n\nLatitude", zlab = "\n\nDays Since First Detection",
main = NULL, xlim = x_lim, ylim = y_lim, zlim = z_lim,
phi = phi, theta = theta, colkey = FALSE
)
# --- 5. Add Topographic Map to the Base ---
image3D(
z      = z_lim[1],
colvar = t_elevation_matrix,
x      = elev_x,
y      = elev_y,
pmat   = pmat,
add    = TRUE,
colkey = FALSE,
col    = terrain_colors
)
# --- 6. Add Main Data Points ---
scatter3D(
x   = merged_data$longitude,
y   = merged_data$latitude,
z   = merged_data$time_days,
add = TRUE,
col = point_colors,
cex = merged_data$point_size,
pch = 19
)
legend(
"topright", inset = c(0.05, 0.1),
legend = c("2019", "2020"),
col = c(color_year_2019, color_year_2020),
pch = 19, bty = "n", cex = 1.0,
title = "Detection Year", title.adj = 0.1
)
# Close the SVG device to save the file.
dev.off()
print(paste("Plot saved to:", file.path(output_path, output_filename)))
# Define file paths. These should be the paths to your data files.
# NOTE: The script uses the placeholder filenames as provided in the environment.
# You should replace "input_file_1.csv" and "input_file_0.csv" with your actual file paths.
spatial_data_path <- "E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/t1_spatiotemporal_data.csv"
seasonal_data_path <- "E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/t1_seasonal_trend_data.csv"
# Define the output path and filename for the plot.
output_path <- "." # Current directory
output_filename <- "3D_Spatiotemporal_Scatter_Plot.svg"
# Define the color palette based on your preference.
# We will use a subset of these for a clean, 2-3 color scheme.
color_palette <- list(
purple_dark = "#B6B3D6",
coral = "#F1837A",
grey_light = "#D5D1D1"
)
# Assign colors for plot elements
color_year_2019 <- color_palette$coral
color_year_2020 <- color_palette$purple_dark
color_projection <- color_palette$grey_light
# --- 2. Data Loading and Preparation ---
# Read the spatiotemporal and seasonal data
spatiotemporal_data <- read.csv(spatial_data_path)
seasonal_data <- read.csv(seasonal_data_path)
# Convert the 'detection_date' column to Date objects for manipulation.
spatiotemporal_data$detection_date <- as.Date(spatiotemporal_data$detection_date)
# Create a numeric Z-axis for time: "Days Since First Detection".
# This makes the time axis quantitative and easy to interpret.
min_date <- min(spatiotemporal_data$detection_date)
spatiotemporal_data$time_days <- as.numeric(spatiotemporal_data$detection_date - min_date)
# Extract the month number to join with the seasonal data.
spatiotemporal_data$month <- as.numeric(format(spatiotemporal_data$detection_date, "%m"))
# Merge the spatial data with seasonal data to get 'case_count' for each point.
merged_data <- merge(spatiotemporal_data, seasonal_data, by = "month", all.x = TRUE)
# Handle potential missing values in case_count after the merge (if any).
merged_data$case_count[is.na(merged_data$case_count)] <- 1
# Map 'case_count' to point size ('cex'). We scale the sizes for better visual representation.
# Formula: base_size + scaled_size. This ensures all points are visible.
merged_data$point_size <- 0.8 + (merged_data$case_count / max(merged_data$case_count)) * 2
# Create a color vector based on the detection year.
merged_data$year_factor <- as.factor(merged_data$year)
point_colors <- ifelse(merged_data$year_factor == "2019", color_year_2019, color_year_2020)
# --- 3. Plot Generation ---
# Set up the SVG output device. This will save the plot to a file.
svglite(file.path(output_path, output_filename), width = 10, height = 8)
# Define plot boundaries, adding some padding for aesthetics.
x_lim <- range(merged_data$longitude) + c(-0.1, 0.1)
y_lim <- range(merged_data$latitude) + c(-0.1, 0.1)
z_lim <- c(0, max(merged_data$time_days) + 20)
# Set the viewing angle for the 3D plot.
phi <- 25
theta <- -45
# Create the main 3D scatter plot.
# This first call to scatter3D sets up the entire plot area.
scatter3D(
x = merged_data$longitude,
y = merged_data$latitude,
z = merged_data$time_days,
# --- Aesthetics ---
col = point_colors,
cex = merged_data$point_size,
pch = 19, # Solid circles
# --- Box and Axes Style ---
bty = "g", # Box with grey background and white grid lines.
ticktype = "detailed", # Ticks point outwards, matching journal style.
# --- Labels and Title ---
xlab = "\n\nLongitude", # Add newlines for spacing
ylab = "\n\nLatitude",
zlab = "\n\nDays Since First Detection",
main = NULL, # No title on the plot itself, as requested.
# --- Plot and Viewport ---
xlim = x_lim, ylim = y_lim, zlim = z_lim,
phi = phi, theta = theta,
# --- Legend ---
colkey = FALSE # Turn off the default continuous color key.
)
# Add projections onto the planes to replicate the example's style.
# These are added as smaller, semi-transparent points.
# Projection on XY plane (bottom)
scatter3D(
x = merged_data$longitude, y = merged_data$latitude, z = rep(z_lim[1], nrow(merged_data)),
add = TRUE, col = color_projection, pch = 19, cex = 0.5
)
# Projection on XZ plane (back wall)
scatter3D(
x = merged_data$longitude, y = rep(y_lim[2], nrow(merged_data)), z = merged_data$time_days,
add = TRUE, col = color_projection, pch = 19, cex = 0.5
)
# Projection on YZ plane (left wall)
scatter3D(
x = rep(x_lim[1], nrow(merged_data)), y = merged_data$latitude, z = merged_data$time_days,
add = TRUE, col = color_projection, pch = 19, cex = 0.5
)
# Add a legend to explain the colors for the years.
legend(
"topright",
inset = c(0.05, 0.1), # Adjust inset to position legend nicely.
legend = c("2019", "2020"),
col = c(color_year_2019, color_year_2020),
pch = 19,
bty = "n", # No box around the legend.
cex = 1.0,
title = "Detection Year",
title.adj = 0.1 # Adjust title position
)
# Close the SVG device, which saves the file.
dev.off()
print(paste("Plot saved to:", file.path(output_path, output_filename)))
library(ggplot2)
library(svglite)
library(dplyr)
library(tidyr)
library(tidyr)
library(ggdist)
# --- 1. 定义莫兰迪配色方案 ---
my_pal <- c(
purple_dark = "#B6B3D6",
purple_light = "#CFCCE3",
coral = "#F1837A",
peach = "#F8B2A2",
nude = "#F6DFD6",
pink_dark = "#E9687A",
grey_purple = "#D5D3DE",
grey_light = "#D5D1D1"
)
# --- 2. 通用专业主题设置 ---
theme_journal <- function() {
theme_bw() +
theme(
panel.border = element_rect(colour = "black", fill=NA, linewidth=1), # 四边框
axis.ticks = element_line(colour = "black"),
axis.ticks.length = unit(-0.15, "cm"), # 刻度向外 (通过负值配合margin)
axis.text.x = element_text(margin = margin(t = 10)),
axis.text.y = element_text(margin = margin(r = 10)),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "top",
legend.title = element_blank(),
text = element_text(family = "sans", size = 12)
)
}
# 假设数据读取路径 (请根据实际修改)
setwd("E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/T2")
# =================================================================
# 2.1 模型性能对比 (分组柱状图 + 差值标注)
# =================================================================
df_21 <- read.csv("plot_2_1_model_comparison.csv")
# 过滤关键指标进行展示
df_21_plot <- df_21 %>% filter(Metric %in% c("auprc_mean", "uplift_5_mean", "auroc_mean"))
p1 <- ggplot(df_21_plot, aes(x = Metric, y = Value, fill = Model)) +
geom_bar(stat = "identity", position = position_dodge(0.8), width = 0.7, color = "white") +
scale_fill_manual(values = c("With Images" = my_pal["coral"], "Without Images" = my_pal["purple_dark"])) +
labs(x = "Evaluation Metrics", y = "Score") +
theme_journal() +
# 留出标注空位，添加指示箭头示例 (LaTeX后续可标注具体提升%)
annotate("segment", x = 1.8, xend = 2.2, y = 0.8, yend = 0.8, arrow = arrow(length = unit(0.2, "cm")))
ggsave("Chart_2_1_Comparison.svg", p1, width = 8, height = 6, device = "svglite")
ggsave("Chart_2_1_Comparison.svg", p1, width = 8, height = 6, device = "svglite")
library(svglite)
ggsave("Chart_2_1_Comparison.svg", p1, width = 8, height = 6, device = "svglite")
install.packages("svglite")
library(svglite)
library(svglite)
ggsave("Chart_2_1_Comparison.svg", p1, width = 8, height = 6, device = "svglite")
library(ggplot2)
library(dplyr)
library(svglite)
library(showtext)
# 莫兰迪配色方案定义
my_colors <- c(
purple_dark  = "#B6B3D6",
purple_light = "#CFCCE3",
coral        = "#F1837A",
pink_dark    = "#E9687A",
nude         = "#F6DFD6",
grey_purple  = "#D5D3DE"
)
# 杂志风主题：四边框封闭，刻度线向外
journal_theme <- theme_bw() +
theme(
panel.grid = element_blank(),
panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.8),
axis.ticks.length = unit(0.2, "cm"), # 刻度线长度
axis.ticks = element_line(colour = "black"),
legend.position = "top",
legend.title = element_blank(),
axis.text = element_text(color = "black", size = 10),
plot.margin = margin(20, 20, 20, 20)
)
# 假设数据读取路径 (请根据实际修改)
setwd("E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/T2")
# 2.1 分组柱状图
df_21 <- read.csv("plot_2_1_model_comparison.csv")
# 仅保留关键对比指标：AUROC, AUPRC, Uplift@5%
df_21 <- df_21 %>% filter(Metric %in% c("auroc_mean", "auprc_mean", "uplift_5_mean"))
p1 <- ggplot(df_21, aes(x = Metric, y = Value, fill = Model)) +
geom_bar(stat = "identity", position = position_dodge(0.7), width = 0.6) +
scale_fill_manual(values = c("With Images" = "#F1837A", "Without Images" = "#B6B3D6")) +
scale_y_continuous(expand = expansion(mult = c(0, 0.15))) + # 顶部留白方便加标注
labs(x = "Evaluation Metrics", y = "Performance Score") +
journal_theme +
# 添加指示箭头示例（在 AUPRC 之间）
annotate("segment", x = 1.85, xend = 2.15, y = 0.7, yend = 0.7,
arrow = arrow(length = unit(0.2, "cm")), color = "black")
ggsave("Chart_2_1_Comparison.svg", p1, width = 7, height = 5)
# 2.2 水平条形图
df_22 <- read.csv("plot_2_2_feature_importance.csv")
p2 <- ggplot(df_22, aes(x = reorder(Feature, Abs_Coefficient), y = Coefficient, fill = Coefficient > 0)) +
geom_bar(stat = "identity", width = 0.75) +
coord_flip() +
scale_fill_manual(values = c("TRUE" = "#F1837A", "FALSE" = "#CFCCE3")) +
labs(x = NULL, y = "Model Coefficient (Influence)") +
journal_theme +
theme(axis.ticks.y = element_blank()) # 纵轴不显刻度更整洁
ggsave("Chart_2_2_Importance.svg", p2, width = 6, height = 6)
## 2.3 KDE Plot
df_23 <- read.csv("plot_2_3_prob_dist.csv")
p3 <- ggplot(df_23, aes(x = prob_positive, fill = Lab.Status)) +
geom_density(alpha = 0.7, color = "white") +
scale_fill_manual(values = c("Positive ID" = "#E9687A", "Negative ID" = "#D5D3DE")) +
labs(x = "Predicted Probability of Positive ID", y = "Density") +
journal_theme +
theme(legend.position = c(0.8, 0.8))
ggsave("Chart_2_3_Distribution.svg", p3, width = 7, height = 5)
# 2.4 Confusion Matrix Heatmap
df_24 <- read.csv("plot_2_4_confusion_matrix.csv")
p4 <- ggplot(df_24, aes(x = factor(Predicted), y = factor(Actual), fill = Count)) +
geom_tile(color = "white", size = 1.5) +
geom_text(aes(label = Count), size = 5, family = "sans", fontface = "bold") +
scale_fill_gradient(low = "#F6DFD6", high = "#F1837A") +
scale_x_discrete(labels = c("0" = "Negative\n(Predicted)", "1" = "Positive\n(Predicted)")) +
scale_y_discrete(labels = c("0" = "Negative\n(Actual)", "1" = "Positive\n(Actual)")) +
labs(x = NULL, y = NULL) +
journal_theme +
theme(axis.ticks = element_blank())
ggsave("Chart_2_4_Confusion.svg", p4, width = 5, height = 5)
# 1. Font Setup (Crucial for the "Journal" look)
# Load a serif font that mimics Times New Roman
font_add_google("Merriweather", "journal_font")
showtext_auto()
# 2. Refined Color Palette & Theme
# Using a "Rich" palette: slightly more vibrant for contrast
my_colors <- c(
red = "#E9687A",       # Coral Red
blue = "#6A9EB5",      # Muted Blue (better contrast than purple)
grey_light = "#F0F0F0",
text_dark = "#2C3E50"
)
# Enhanced Theme
journal_theme <- theme_minimal(base_family = "journal_font") +
theme(
# Clean borders and grid
panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
panel.grid.major = element_line(color = "grey90", linetype = "dashed"),
panel.grid.minor = element_blank(),
# Text styling
text = element_text(color = "black"),
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 12, face = "bold"),
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
# Legend styling
legend.position = "top",
legend.background = element_blank(),
legend.box.background = element_blank(),
# Ticks pointing out
axis.ticks = element_line(color = "black"),
axis.ticks.length = unit(0.2, "cm")
)
# Set Working Directory
setwd("E:/美赛/2021C/code/MCM2021c/graphic/1.22 1.0版本画图/T2")
# --- 2.1 Bar Chart (Model Comparison) ---
df_21 <- read.csv("plot_2_1_model_comparison.csv")
df_21 <- df_21 %>% filter(Metric %in% c("auroc_mean", "auprc_mean", "uplift_5_mean"))
p1 <- ggplot(df_21, aes(x = Metric, y = Value, fill = Model)) +
geom_bar(stat = "identity", position = position_dodge(0.7), width = 0.6,
color = "black", size = 0.3) +  # Add black border
# Add Text Labels on top of bars (Rich detail)
geom_text(aes(label = sprintf("%.2f", Value)),
position = position_dodge(0.7), vjust = -0.5,
family = "journal_font", size = 3.5) +
scale_fill_manual(values = c("With Images" = my_colors[["red"]],
"Without Images" = my_colors[["blue"]])) +
scale_y_continuous(expand = expansion(mult = c(0, 0.15)), limits = c(0, 1)) +
labs(x = "Evaluation Metrics", y = "Performance Score", title = "Model Performance Comparison") +
journal_theme
ggsave("Chart_2_1_Comparison_Rich.svg", p1, width = 8, height = 6)
# --- 2.2 Lollipop Chart (Feature Importance) ---
# *CHANGED* from Bar Chart to Lollipop for a cleaner, modern look
df_22 <- read.csv("plot_2_2_feature_importance.csv")
p2 <- ggplot(df_22, aes(x = reorder(Feature, Abs_Coefficient), y = Coefficient)) +
# Vertical line at 0
geom_hline(yintercept = 0, color = "black", size = 0.5) +
# The Stick
geom_segment(aes(xend = Feature, yend = 0), color = "grey50", size = 0.8) +
# The Pop (Point)
geom_point(aes(fill = Coefficient > 0), shape = 21, size = 4, color = "black") +
coord_flip() +
scale_fill_manual(values = c("TRUE" = my_colors[["red"]],
"FALSE" = my_colors[["blue"]]), labels=c("Negative", "Positive")) +
labs(x = NULL, y = "Model Coefficient (Influence)", title = "Feature Importance Analysis") +
journal_theme +
theme(legend.position = "none") # Legend often redundant here if color implies sign
ggsave("Chart_2_2_Importance_Rich.svg", p2, width = 7, height = 7)
# --- 2.3 KDE Plot (Distribution) ---
df_23 <- read.csv("plot_2_3_prob_dist.csv")
p3 <- ggplot(df_23, aes(x = prob_positive, fill = Lab.Status, color = Lab.Status)) +
# Density with transparency and border
geom_density(alpha = 0.4, size = 1) +
# Add Rug Plot at bottom (Shows actual data density)
geom_rug(alpha = 0.5, length = unit(0.05, "npc")) +
scale_fill_manual(values = c("Positive ID" = my_colors[["red"]],
"Negative ID" = my_colors[["blue"]])) +
scale_color_manual(values = c("Positive ID" = my_colors[["red"]],
"Negative ID" = my_colors[["blue"]])) +
labs(x = "Predicted Probability", y = "Density", title = "Probability Density Distribution") +
journal_theme +
theme(legend.position = c(0.85, 0.85)) # Inset legend
ggsave("Chart_2_3_Distribution_Rich.svg", p3, width = 8, height = 6)
# --- 2.4 Confusion Matrix (Rich Heatmap) ---
df_24 <- read.csv("plot_2_4_confusion_matrix.csv")
# Pre-calculate Percentages
total_count <- sum(df_24$Count)
df_24 <- df_24 %>%
mutate(Percent = Count / total_count * 100,
Label = paste0(Count, "\n(", sprintf("%.1f", Percent), "%)"))
p4 <- ggplot(df_24, aes(x = factor(Predicted), y = factor(Actual), fill = Count)) +
geom_tile(color = "white", lwd = 2) + # Thick white borders
# Rich Text: Count + Percentage
geom_text(aes(label = Label), size = 5, family = "journal_font", fontface = "bold") +
scale_fill_gradient(low = "#FFF5F5", high = my_colors[["red"]]) +
scale_x_discrete(labels = c("0" = "Negative", "1" = "Positive"), position = "top") +
scale_y_discrete(labels = c("0" = "Negative", "1" = "Positive")) +
labs(x = "Predicted Class", y = "Actual Class", title = "Confusion Matrix") +
journal_theme +
theme(
axis.title = element_text(size = 13, face="bold"),
axis.ticks = element_blank(),
panel.border = element_blank() # Heatmaps look better without outer border
)
ggsave("Chart_2_4_Confusion_Rich.svg", p4, width = 6, height = 6)
